import argparse, importlib, os, json, csv 
import numpy as np

from envelope.simulate import evaluate_all_permutations

def load_student_compute():
    mod = importlib.import_module("student_code.my_nav_fn")
    if not hasattr(mod, "compute_gradients"):
        raise RuntimeError("student_code.my_nav_fn must define compute_gradients(...)")
    return mod.compute_gradients

def main():
    p = argparse.ArgumentParser()
    p.add_argument("--n", type=int, default=5)
    p.add_argument("--r", type=float, default=0.05)
    p.add_argument("--dt", type=float, default=0.005)
    p.add_argument("--vmax", type=float, default=0.05)
    p.add_argument("--tol", type=float, default=0.005)
    p.add_argument("--max_steps", type=int, default=30000)
    args = p.parse_args()

    compute = load_student_compute()
    results = evaluate_all_permutations(
        compute_gradients_fn=compute,
        n=args.n, r=args.r, dt=args.dt, vmax=args.vmax, tol=args.tol, max_steps=args.max_steps
    )
    # print(json.dumps(results, indent=2))
    print(f"Summary CSV: {results['csv']}")
    if results["disqualified"]:
        print("NOTE: at least one permutation failed.")
    
    # Additional information
    csv_path = results['csv']
    steps_list = []
    successes = 0
    
    with open(csv_path, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            if row['success'].lower() == 'true':
                successes += 1
                steps_list.append(int(row['steps']))
    
    if successes > 0:
        min_steps = min(steps_list)
        max_steps = max(steps_list)
        avg_steps = sum(steps_list) / successes
        
        print("\n=== Statistics ===")
        print(f"Success rate: {successes}/120 ({successes/120*100:.1f}%)")
        print(f"Minimum steps (successful runs): {min_steps}")
        print(f"Average steps (successful runs): {avg_steps:.1f}")
        print(f"Maximum steps (successful runs): {max_steps}")
        print(f"Standard deviation: {np.std(steps_list):.1f}")
        
        # Additional statistics
        print(f"Steps < 5000: {sum(1 for s in steps_list if s < 5000)} runs")
        print(f"Steps 5000-10000: {sum(1 for s in steps_list if 5000 <= s < 10000)} runs")
        print(f"Steps 10000-15000: {sum(1 for s in steps_list if 10000 <= s < 15000)} runs")
        print(f"Steps â‰¥ 15000: {sum(1 for s in steps_list if s >= 15000)} runs")
        
        # Show the permutation with maximum steps
        with open(csv_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for row in reader:
                if row['success'].lower() == 'true' and int(row['steps']) == max_steps:
                    print(f"\nSlowest permutation: #{row['perm_idx']} with {max_steps} steps")
                    print(f"Permutation: {row['sigma']}")
                    break
        
        # Show the permutation with minimum steps
        with open(csv_path, 'r', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for row in reader:
                if row['success'].lower() == 'true' and int(row['steps']) == min_steps:
                    print(f"Fastest permutation: #{row['perm_idx']} with {min_steps} steps")
                    print(f"Permutation: {row['sigma']}")
                    break
    else:
        print("\nNo successful runs to analyze.")

if __name__ == "__main__":
    main()

n = state.shape[0]
    eps = 1e-12
    
    # Tuned parameters
    k_goal = 3.0
    k_pair = 0.008
    k_obs  = 0.02
    k_wall = 0.05
    
    # Tolerance for reaching target (matches config.py tol=0.005)
    tol = 0.005
    
    V = np.zeros_like(state)
    
    # 1. GOAL ATTRACTION - FIXED: Strong attraction even when close
    to_target = targets - state
    dist_to_target = np.linalg.norm(to_target, axis=1) + eps
    
    for i in range(n):
        # Normalized direction to target
        dir_to_target = to_target[i] / dist_to_target[i]
        
        # CRITICAL FIX: Use a function that doesn't go to zero near target
        # When far: strong attraction
        # When close: still strong enough to overcome repulsions
        if dist_to_target[i] > tol * 3:  # > 0.015
            # Moderate attraction
            attraction_strength = k_goal * np.tanh(dist_to_target[i] * 2.0)
        elif dist_to_target[i] > tol:  # 0.005 - 0.015
            # Maintain decent strength
            attraction_strength = k_goal * 0.1
        else:  # < 0.005
            # Still some attraction to ensure reaching tolerance
            attraction_strength = k_goal * 0.05
        
        V[i] += attraction_strength * dir_to_target
    
    # 2. ROBOT-ROBOT REPULSION - Reduced near targets
    min_pair_dist = 2.0 * r
    
    for i in range(n):
        # Check if robot is very close to its target
        near_target_i = dist_to_target[i] < tol * 2
        
        for j in range(i+1, n):
            # Check if other robot is very close to its target
            near_target_j = dist_to_target[j] < tol * 2
            
            diff = state[i] - state[j]
            d = np.linalg.norm(diff) + eps
            
            # If both robots are near their targets, reduce repulsion
            if near_target_i and near_target_j:
                # Only repel if dangerously close
                if d < min_pair_dist * 1.1:
                    rep_strength = k_pair * 0.5 / ((d - min_pair_dist + 0.02) ** 2)
                else:
                    continue
            else:
                # Normal repulsion
                activation_dist = 3.5 * r
                if d < activation_dist:
                    rep_strength = k_pair / ((d - min_pair_dist + 0.05) ** 3)
                else:
                    continue
            
            rep = rep_strength * diff / d
            V[i] += rep
            V[j] -= rep
    
    # 3. OBSTACLE AVOIDANCE - Reduced near targets
    for i in range(n):
        # Check if robot is very close to its target
        near_target = dist_to_target[i] < tol * 3
        
        pos = state[i]
        
        for obs in obstacles:
            center = np.array(obs["center"])
            radius = obs["radius"]
            
            diff = pos - center
            d = np.linalg.norm(diff) + eps
            min_clearance = radius + r + 0.005
            
            # If robot is near target, obstacle avoidance should be minimal
            if near_target:
                # Only avoid if very close to obstacle
                if d < min_clearance * 1.1:
                    rep_strength = k_obs * 0.5 / ((d - min_clearance + 0.01) ** 2)
                else:
                    continue
            else:
                # Normal obstacle avoidance
                if d < min_clearance + 0.15:
                    rep_strength = k_obs / ((d - min_clearance + 0.03) ** 2)
                else:
                    continue
            
            V[i] += rep_strength * diff / d
    
    # 4. BOUNDARY REPULSION - Reduced near boundary targets
    for i in range(n):
        norm_pos = np.linalg.norm(state[i])
        
        # Check if robot's target is near boundary
        target_norm = np.linalg.norm(targets[i])
        target_near_boundary = target_norm > 0.8
        
        if norm_pos > 0.85:
            to_center = -state[i] / (norm_pos + eps)
            
            # If target is near boundary, reduce boundary repulsion
            if target_near_boundary:
                # Gentle guidance only
                boundary_strength = k_wall * 0.5 * (norm_pos - 0.85) * 5.0
            else:
                # Normal boundary repulsion
                if norm_pos > 0.95:
                    boundary_strength = k_wall * 5.0 / ((1.0 - norm_pos + eps) ** 0.5)
                elif norm_pos > 0.9:
                    boundary_strength = k_wall * 2.0 / ((1.0 - norm_pos + eps) ** 0.3)
                else:
                    boundary_strength = k_wall * (norm_pos - 0.85) * 10.0
            
            V[i] += boundary_strength * to_center
    
    # 5. FINAL VELOCITY ADJUSTMENT - Critical for reaching targets
    for i in range(n):
        # When very close to target, focus ONLY on reaching it
        if dist_to_target[i] < tol * 2:  # < 0.01
            # Strong direct attraction to target, ignore other forces
            target_dir = to_target[i] / (dist_to_target[i] + eps)
            # Scale based on how close we are
            strength = k_goal * 0.3 * (1.0 + 1.0 / (dist_to_target[i] + 0.01))
            V[i] = target_dir * strength
        
        # When moderately close, balance forces
        elif dist_to_target[i] < tol * 10:  # < 0.05
            # Still prioritize goal, but consider other factors
            goal_component = to_target[i] / (dist_to_target[i] + eps) * k_goal * 0.2
            # Reduce existing forces by 50%
            V[i] = goal_component + V[i] * 0.5
    
    # 6. VELOCITY SCALING - Ensure enough velocity when close to target
    norms = np.linalg.norm(V, axis=1, keepdims=True) + eps
    
    # Scale based on distance to target
    for i in range(n):
        if dist_to_target[i] < tol * 5:  # < 0.025
            # When close to target, ensure minimum velocity
            min_velocity = 0.05  # Small but enough to reach target
            current_norm = norms[i, 0]
            if current_norm < min_velocity:
                scale = min_velocity / current_norm
                V[i] *= scale
    
    # Soft cap to prevent extreme velocities
    max_velocity = 1.0
    norms = np.linalg.norm(V, axis=1, keepdims=True) + eps
    scale = np.minimum(1.0, max_velocity / norms)
    V = V * scale
    
    # Ensure no NaN or Inf
    V = np.nan_to_num(V, nan=0.0, posinf=0.0, neginf=0.0)
    
    return V

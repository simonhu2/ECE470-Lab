n = state.shape[0]
    eps = 1e-12
    
    # Optimized parameters
    k_goal = 3.0
    k_pair = 0.012
    k_obs  = 0.018
    k_wall = 0.05
    
    tol = 0.005
    
    V = np.zeros_like(state)
    
    # 1. GOAL ATTRACTION
    to_target = targets - state
    dist_to_target = np.linalg.norm(to_target, axis=1) + eps
    
    for i in range(n):
        dir_to_target = to_target[i] / dist_to_target[i]
        
        if dist_to_target[i] > tol * 3:
            attraction_strength = k_goal * np.tanh(dist_to_target[i] * 2.0)
        elif dist_to_target[i] > tol:
            attraction_strength = k_goal * 0.1
        else:
            attraction_strength = k_goal * 0.05
        
        V[i] += attraction_strength * dir_to_target
    
    # 2. DETECT CROSSING ROBOTS (SPECIFIC TO PROBLEMATIC PERMUTATIONS)
    # These are robots that need to pass through the center to reach opposite-side targets
    crossing_robots = []
    for i in range(n):
        # Vector from robot to target
        robot_to_target = targets[i] - state[i]
        
        # Check if target is on opposite side of center
        # If dot product of position and target direction is negative, target is opposite side
        if np.dot(state[i], robot_to_target) < -0.3:
            # And if path goes near center (distance to center < 0.5)
            if np.linalg.norm(state[i]) < 0.5:
                crossing_robots.append(i)
    
    # 3. PRIORITIZE CROSSING ROBOTS (CRITICAL FIX)
    # If we have multiple crossing robots, let them go one at a time
    if len(crossing_robots) >= 2:
        # Sort by distance to center - closest goes first
        crossing_robots.sort(key=lambda i: np.linalg.norm(state[i]))
        
        # Let only the first 1-2 robots actively cross, others wait
        for idx, i in enumerate(crossing_robots):
            if idx == 0:
                # First robot: full speed ahead
                continue
            elif idx == 1:
                # Second robot: reduced speed to follow
                continue
            else:
                # Other robots: significantly reduce goal attraction and wait
                V[i] *= 0.3  # Reduce all velocities
                # Add waiting behavior - move perpendicular to goal to get out of way
                goal_dir = to_target[i] / (dist_to_target[i] + eps)
                perp_dir = np.array([-goal_dir[1], goal_dir[0]])
                V[i] += perp_dir * 0.1
    
    # 4. ROBOT-ROBOT REPULSION
    min_pair_dist = 2.0 * r
    
    for i in range(n):
        near_target_i = dist_to_target[i] < tol * 2
        
        for j in range(i+1, n):
            near_target_j = dist_to_target[j] < tol * 2
            
            diff = state[i] - state[j]
            d = np.linalg.norm(diff) + eps
            
            # CRITICAL: Reduced repulsion for crossing robots near center
            # This allows them to pass through narrow space
            both_crossing = i in crossing_robots and j in crossing_robots
            near_center = np.linalg.norm(state[i]) < 0.4 and np.linalg.norm(state[j]) < 0.4
            
            if both_crossing and near_center:
                # Very gentle repulsion to allow passing
                if d < min_pair_dist * 1.1:
                    rep_strength = k_pair * 0.1 / ((d - min_pair_dist + 0.03) ** 2)
                else:
                    continue
            elif near_target_i and near_target_j:
                if d < min_pair_dist * 1.1:
                    rep_strength = k_pair * 0.5 / ((d - min_pair_dist + 0.02) ** 2)
                else:
                    continue
            else:
                activation_dist = 3.5 * r
                if d < activation_dist:
                    rep_strength = k_pair / ((d - min_pair_dist + 0.05) ** 3)
                else:
                    continue
            
            rep = rep_strength * diff / d
            V[i] += rep
            V[j] -= rep
    
    # 5. OBSTACLE AVOIDANCE - WITH CLEAR PASSAGEWAYS
    for i in range(n):
        near_target = dist_to_target[i] < tol * 3
        pos = state[i]
        
        for obs in obstacles:
            center = np.array(obs["center"])
            radius = obs["radius"]
            
            diff = pos - center
            d = np.linalg.norm(diff) + eps
            min_clearance = radius + r + 0.005
            
            is_central_obstacle = np.linalg.norm(center) < 0.01
            
            # CRITICAL: Create passageways for crossing robots
            if is_central_obstacle and i in crossing_robots:
                # For crossing robots, we need clear paths through/around center
                
                # Check which side of the obstacle the target is on
                target_vec = targets[i] - center
                robot_vec = pos - center
                
                # Cross product to determine which way to go around
                cross = np.cross([robot_vec[0], robot_vec[1], 0], 
                                [target_vec[0], target_vec[1], 0])[2]
                
                # Create directional avoidance
                if abs(cross) < 0.1:  # Target is nearly straight through
                    # Go straight but with gentle guidance
                    if d < min_clearance + 0.15:
                        # Push robot slightly to the side based on its index
                        side_dir = np.array([-diff[1], diff[0]])  # Perpendicular
                        side_dir = side_dir / (np.linalg.norm(side_dir) + eps)
                        # Even indices go one way, odd the other
                        if i % 2 == 0:
                            avoid_dir = (diff / d) + 0.3 * side_dir
                        else:
                            avoid_dir = (diff / d) - 0.3 * side_dir
                        
                        avoid_dir = avoid_dir / (np.linalg.norm(avoid_dir) + eps)
                        rep_strength = k_obs * 0.5 / ((d - min_clearance + 0.05) ** 1.5)
                        V[i] += rep_strength * avoid_dir
                else:
                    # Go around the obstacle
                    tangent = np.array([-diff[1], diff[0]])
                    tangent = tangent / (np.linalg.norm(tangent) + eps)
                    
                    # Choose direction that moves toward target
                    if cross > 0:
                        # Target is clockwise, go clockwise
                        avoid_dir = tangent
                    else:
                        # Target is counter-clockwise
                        avoid_dir = -tangent
                    
                    if d < min_clearance + 0.2:
                        rep_strength = k_obs * 0.6 / ((d - min_clearance + 0.04) ** 1.5)
                        V[i] += rep_strength * avoid_dir
            
            # Normal obstacle avoidance for non-crossing or non-central
            elif is_central_obstacle:
                if near_target:
                    if d < min_clearance * 1.2:
                        rep_strength = k_obs * 0.3 / ((d - min_clearance + 0.02) ** 1.5)
                        V[i] += rep_strength * diff / d
                else:
                    if d < min_clearance + 0.2:
                        if d < min_clearance * 1.05:
                            rep_strength = k_obs * 2.0 / ((d - min_clearance + 0.01) ** 2.0)
                        else:
                            rep_strength = k_obs * 0.8 / ((d - min_clearance + 0.05) ** 1.8)
                        V[i] += rep_strength * diff / d
            else:
                if near_target:
                    if d < min_clearance * 1.1:
                        rep_strength = k_obs * 0.5 / ((d - min_clearance + 0.01) ** 2)
                        V[i] += rep_strength * diff / d
                else:
                    if d < min_clearance + 0.15:
                        rep_strength = k_obs / ((d - min_clearance + 0.03) ** 2)
                        V[i] += rep_strength * diff / d
    
    # 6. BOUNDARY REPULSION
    for i in range(n):
        norm_pos = np.linalg.norm(state[i])
        target_norm = np.linalg.norm(targets[i])
        target_near_boundary = target_norm > 0.8
        
        if norm_pos > 0.85:
            to_center = -state[i] / (norm_pos + eps)
            
            if target_near_boundary:
                boundary_strength = k_wall * 0.5 * (norm_pos - 0.85) * 5.0
            else:
                if norm_pos > 0.95:
                    boundary_strength = k_wall * 5.0 / ((1.0 - norm_pos + eps) ** 0.5)
                elif norm_pos > 0.9:
                    boundary_strength = k_wall * 2.0 / ((1.0 - norm_pos + eps) ** 0.3)
                else:
                    boundary_strength = k_wall * (norm_pos - 0.85) * 10.0
            
            V[i] += boundary_strength * to_center
    
    # 7. FINAL VELOCITY ADJUSTMENTS
    for i in range(n):
        if dist_to_target[i] < tol * 2:
            target_dir = to_target[i] / (dist_to_target[i] + eps)
            strength = k_goal * 0.3 * (1.0 + 1.0 / (dist_to_target[i] + 0.01))
            V[i] = target_dir * strength
        elif dist_to_target[i] < tol * 10:
            goal_component = to_target[i] / (dist_to_target[i] + eps) * k_goal * 0.2
            V[i] = goal_component + V[i] * 0.5
    
    # 8. VELOCITY SCALING
    norms = np.linalg.norm(V, axis=1, keepdims=True) + eps
    
    for i in range(n):
        if dist_to_target[i] < tol * 5:
            min_velocity = 0.05
            current_norm = norms[i, 0]
            if current_norm < min_velocity:
                scale = min_velocity / current_norm
                V[i] *= scale
    
    max_velocity = 1.0
    norms = np.linalg.norm(V, axis=1, keepdims=True) + eps
    scale = np.minimum(1.0, max_velocity / norms)
    V = V * scale
    
    V = np.nan_to_num(V, nan=0.0, posinf=0.0, neginf=0.0)
    
    return V
